# closures_and_objects  

### Содержание  

[2 Лекс обл вид](#2)  
[3 Функциональные и блочные области видимости](#3)  
[4 Поднятие ](#4)  
[5 Замыкание обл вид ](#5)   
[6 this обретает смысл](#6)   
[7 Объекты](#7)  
[8 Классы](#8)  
[9 Прототипы](#9)
[10 Делегирование поведения](#10)



**Область видимости** - набор правил определяющих, где и как осуществляется поиск переменной(идентификатора).  

## Теория компиляторов

3 фазы:
**1.tokenizing(Разбиение на токены)/lexing(Лексический анализ)** - разбиение последовательности символов на осмысленные фрагменты(токены)  
**2.Разбор**(parsing) - преобразование массива токенов в дерево вложенных эл.(AST)  
**AST** - абстрактное дерево синтаксиса.  
**3.Генерирование кода** - процес преобразования AST в испоняемый код.  

Компилятор  js берет программу и сначала компилирует её, а затем готовит к исполнению.

## Разбираемся в областях видимости

**Движок** - отвечает за всю компиляцию и выполнение программы JS.  
**Компилятор** - разбирает и генерирует код.  
**Область видимости** - собирает и ведёт список всех объявленных переменных(идентификаторов) и устанавливает строгий набор правил  
их доступности для кода, выполняемого в данный момент.  

Для присваивания значения переменной выполняется два разных дествия. Сначала Компилятор объявляет переменную(если она не была объявлена ранее) в текущей области  
видимости, а затем при выполнении Движок ищет переменную в Области видимости, и если переменная не будет найдена - присваивает ей значение.

LHS(приёмник присваивания(присваивание переменной)) & RHS(источник присваивания(чтение значения))

Если RHS не находит переменную ни в одной из вложенных областей, то он считает пер. необъявленной и движок выдаёт ошику ReferenceError.  
LHS  в таком случае создает новую пер. в глоб. обл. вид. с указанным именем, которая передаётся движку.(не strict, если strict то ReferenceError)

Режим strict:  
 - запрещает авт/неявное создание глоб.пер.

Если пер. будет найдена для RHS-поиска, но вы пытаетесь  сделаеть с её значчение нечто невозможное (попытка вып. как функцию знач., которое функцией не являетсяь, или  
обращение к свойству для значения null & undefined), движок выдаст другую ошибку - TypeError.  

Ошибка ReferenctError относится к проблемам при разрешении области видимости, а ошибка TypeError подразумевает, что разрешение области видимости прошло успешно,  
но была сделана попытка вып.  с результатом недопустимую/невозможную операцию.

## <a name="2"></a> 2 Лексическая область видимости(модель работы обл.вид.)

Обл. вид. определена как набор правил,  управляющих тем, как движок ищет переменную по её идентфикатору и находит её в текущей обл. вид или люб. др.
Лексический анализ изучает последовательность символов исходного кода и назначает семантический смысл токенам в результате разбора с учетом состояния.  
**Лексческая обл. вид.** наз. обл. вид., определяемая на стадии лексического анализа. Она определяется  тем, где мы разместили переменные и блоки видимости.  

Замещение - когда внутренний идентификатор 'замещает' внешний.  
Все идёт изнутри наружу.  

Лексическая обл. вид. опр. тем где была объявлена функция или переменная.  
Ключевая характеристика лекс обл вид - её опр на стадии написания кода.  
Лекс обл вид ищет  ссылки на пер  поднимаясь вверх по (вложенным обл вид), а динамическая поднимается вверх по стеку.

### Eval  

Функция Eval получает строковый аргумент и интерпретирует содержимое строки так, словно это реальный код в тек. точке программы  и позволяет изм.
лексическуб обл. видимости на стадии выполнения.  
В режиме strict она не изменяет внеш.обл.вид. 


## <a name="3"></a> 3 Функциональные и блочные области видимости  

Обл. вид. состоит их пузырей(контейнеров), в котором объявляются идентификаторы(переменные, функции). Пузыри вложены друг в друга, причём это вложение  
определяется во время написания кода.

### Области видимости из функции(функциональная обл. вид.)  

Динамической обл вид  не важно где и как объявл функ и области видимости, важно лишь то, где они вызываются.  
Цепочка обл вид основана на стеке вызовов, а не на вложености обл вид.  


Функциональная область видимости подчёркивает ту идею, что все переменные принадлежат функции и могут исп. во всей этой Ф.( и даже быть доступными для  
вложенных обл. вид.)  
Идентификаторы доступны в области видимости, где они объявлены и ниже. 
Например: некоторой функции принадлежат идентификаторы a,b,c,если мы выведем их console.log( a,b,c), то получим ReferenceError(они недоступны в глобал скоуп).

Скрытый код заключается в обл вид Ф.
Это даёт нам:  
- более правильная архитектура и качественный код(принцип наименьших привелегий;  
- предотвращение кофликтов идентификаторов с одним именем, но разными значениями   

Функции как обл.вид.  

Это не интерпретация функции как стандартное объявление(связь с внешн обл вид), а интерпретация функции как функционального выражение(связь только со своей функцией {})  
(function foo(){})()  
Ключевое различие представляет то, где имя связывается с идентификатором.  

**Анонимное функциональное выражение** - выражение, где нет идентификатора.( но в объявлении функ должно быть имя)

Минусы АФВ:  
- не имеют содержательного имени, которое могло бы выводиться в трассировке стека, что может усложнить отладку.  
- при отстутсвии имени, если нужна рекурсия, то надо исп arguments.callee...  
- Содержательное имя способствует самодокументированию кода.  

**Паттерн** - конструкция, которую исп для решения какой либо проблемы в рамках часто возникающего контекста.  

IIFE(Immediately Invoked Function Expression(немедленно вызываемое функциональное выражение)  (function foo(){})()  

### Блоки как обл вид  

### let  

Ключевое слово **let** присоединяет  объявление переменной к области видимости блока {}, в которой оно содержится.  
**let** неявно заимствует область видимости любого  блока для объявления своей переменной.  
Объявления с let  не будут подниматься на всю обл вид того блока, в котором они присутсвуют. Такие объявления не будут 'существовать' в блоке до команды объявления.


## <a name="4"></a> 4 Поднятие  

В одной из фаз компилятор находит и связывает все объявления с соотв обл вид.  
var a = 2  
var a - компиляция  
a = 2 - исполнение  
Объявл переменных и функций 'перемещаются' из текущей позиции в начало кода(текущей области видимости). Происходит **hosting**

Сначала функции, потом переменные.  
После поднятия дублирующих функций - результатом будет последняя.

## <a name="5"></a> 5 Замыкание обл вид  

**Замыкание** - способн функ запоминать свою лекс обл вид и обращаться к ней даже тогда, когда функ выполн вне своей лекс обл вид.  
Замыкания возникают в результате написания кода, полагающегося на лкс обл вид.

```
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  bar();
}

foo();
```
Функ bar() обладает доступом к пер а во внешн обл вид из-за правил поиска лекс обл вид(RHS-ссылки).  
Функ bar() обладает замыканием над областью вид foo() (а на самом деле и над остальными областями видимсоти, доступными для неё, например, глобальной обл вид).  
bar () обладает замыканием над обл вид foo(). Потому что функция bar() вложена в foo().  
```
function foo() {
  var a = 2;
  function bar() {
    return a;
  }
  return bar;
}

var baz = foo();

console.log(baz());
```  
Функ bar() обладает доступом лекс обл вид к внутр обл вид foo(). Но затем мы берём bar() (саму функцию) и передаём её как значение. В этом случае return возвращает сам объект  
функ, на который ссылается bar().  
После вып foo() возвращенное значение(наша внутр функ bar()) присваивается пер с именем baz, после чего происходит вызов baz(), что, естественно, означает вызов нашей внутр  
функ bar(), просто по другому идентификатору.  
Функ bar() обладает замыканием лекс обл вид над внутр обл вид foo(). Поэтому данная обл вил продолжает существовать для bar(), что позволяет обратиться к ней в любой   
последующий момент времени.
bar  всё ещё содержит ссылку на эту обл вид, и эта ссылка наз **замыканием**  
При вызове baz(то есть вызове внутр функции, которая называется bar) эта переменная обладает доступом к лекс обл вид, определяемой на стадии написания программы, так что  
она может обратиться к переменной a.  

Функция вызывается за пределами своей лекс обл вид. Замыкание позволяет функции продолжить обращаться к лекс обл вид, определенной на стадии написания программы.  
**Замыкание** - это ссылка, которая позволяет обратиться к лекс обл вид, определённой на стадии написания кода.  
 
 
 ``` 
 function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}

console.log(wait("hello"));
 ``` 
 
 Мы берём внутр функ(с именем timer) и передаем её setTimeout(..). Однако функция timer имеет замыкание над областью видимости wait(..) вследствие чего эта функция поддреживает и исп ссылку на пер message.  
 Через 1000 миллисекунд после того, как функция wait была выполнена, а ее внутр обл вид должна была давно исчезнуть, анонимная функция все еще имеет облсть замыкания над этой обл вид.

В любое время и влюбом месте, где вы интепретируете функ(которые обращаются к своим соответствующим лек обл вид) как полнопраыне значения и передаете их,  скорее всего, вы видите, как эти функции исп замыкания.Таймеры, обработчики события, запросы,Ajax  и др асинхронные задачи и т.д. и т.п..К каждой функции обр вызова прилагается замыкание.
 ``` 
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
 ``` 
 Проблема этого фрагмента кода с обл вид, каждой итерации надо своя обл вид, а они всек замыкаются на глобальной(там одно i), поэтому  надо просто создать дял каждой итерации свою обл вид.
 
 Модули не совсем разобраны.   109 - 114
 
 **Замыкание** - ссылка дающая способность функ запоминать свою лекс обл вид и обращаться к ней, даже когда функ вызывается за пределами своей лекс обл вид.  
 
 Модуль - это паттерн.  
 Самый распространенный способ реализации - **предоставление**(revealing)
 
 Модули должны обладать:  
 - вызываемая внешняя функция-обертка для создания внешн обл вид  
 - возвращаемое знач функции-обёртки должно вкл ссылку хотя бы на одну внутр функцию, которая обладает замыканием над приватной внутр обл вид обёртки.

## Приложение A. Динамическая обл вид  
 
 function foo() {
  console.log(a);
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;

bar();

В лекс обл вид а = 2 т к  ссылка на а ищется при переходе  вверх по вложенным(лекс) обл вил  
В динам обл вил а = 3 т к значение ищется поднимаясь вверх по стеку  

Лекс обл вид опр во время выполнения.Для лекс обл вид важно то, где функция объявлена, а для динамической - где она была вызвана  
Для this  важно то, как функ была вызывана  

## Приложение Б. Полифилы для блочной обл вид  

Traceur

## Приложение В. Лексическое this  

## this  и прототипы объектов    

## 6 Что такое this?  

this указывает на объект в контексте которого он был вызван  
this обозначает спец идентификатор, который авомотически определяется в области видимости каждой функции.  
Связывание this происходит в момент вызова функ, и то, на что ссылается this, определяется исключительно местом вызова, из которога была вызвана функ.    

## this обретает смысл  


### Личные размышления
 ``` 
function foo() {
  let a = 2;
  bar();
}

function bar() {
  console.log(a);
}
foo();
 ```   

Мы получаем ReferenceError: a is not defined т к  у  функ bar() нету ссылки на пер a  
Почему?  
Потому что мы не передали a  в аргумент bar и не сделали параметр для функ bar   
или  
у foo & bar разные обл видимости и RHC не может найти a

## <a name="6"></a>  this обретает смысл!  

Связывание this осущ для каждого вызова функции на основании исключительно места вызова(стек вызовов), которое находится непосредственно перед текущей вып функ.

Чтобы понять , что явл this определите какое из 4 правил будет работать

### 1 Связывание по умолчанию   

1-ое правило происходит от самого распространённого случая вызова функии:**автономный вызов функции**. Это правило исп по умолчанию, если др не работают.   
 ``` 
var a = 2;
function foo() {
  console.log(this.a);
}

foo();
 ``` 
Конструкция this.a превращается в глоб пер **а**.Почему? Потому, что в этом случае связывание по умолчанию this применяется к вызову функции, следовательно, this  
указывает на глоб обл вид.  В нашем фрагменте foo() вызывается с простой,  неизменной ссылкой на функцию.  

### 2 Неявное связывание  

Другое правило, которое необходимо учитывать, - наличие места вызова контекстного объекта, также называемого **владельцем** или **содержащим объектом**  
 ``` 
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};
 ```  
 obj явл владельцем или содержит ссылку на foo только на момент вызова.  
 Когда при обращении к функции указывается контекстный объект, правило неявного связывания требует, чтобы этот объект  исп для связывния this данного вызова функции.  
 Посколько obj становится this для вызова foo(), синтаксис this.a явл синонимом obj.a.  
 Для места вызова важен только верхний/последний уровень цепочки ссылок на свойства объекта.
  ``` 
 var obj2 = {
  a: 42,
  foo: foo,
};

var obj1 = {
  a: 2,
  obj2: obj2,
};

obj1.obj2.foo(); // 42
 ``` 
 
 ### Неявная потеря this  
 
 Одна из самых распространённых проблем, возникающих при связывании, - когда функция с неявным связыванием теряет это связывание, что бычно означает возврат к связыванию  
 по умолчанию - глобальному объекту или undefined в зависимости от действия режима strict.
  ``` 
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};

var bar = obj.foo();
var a = "oops,global";
bar(); // oops,global

 ``` 
И хотя bar кажется ссылкой на obj.foo в действительности это всего лишь еще одна ссылка на саму функцию foo. Кроме того, важно только место вызова, а здесь оно имеет вид bar() - 
простой вызов без прфикса, а следовательно, здесь применяется связывание по умолчанию.  
Передача параметров - всего лишь неявное присваивание,  а посколько мы прел=даём функцию,  происходит неявное присваивание ссылки, поэтому конечный результат будет таким же, как в предыдущем фрагменте.   

Надо сделать изменить объект для включения ссылки на функцию и исп эту ссылку на функцию в свойстве неявного(косвенного) связывания this с объектом.

###  3 Явное связывание  

У всех функций есть ([[Prototype]])  и методы call & apply. Эти методы получают в первом параметре объект, который явл знач this.  
Простое примитивное значение(boolean & string & number) будет преобразовано в объектную форму(new String(...), new Boolean(...) ...) 

### Жесткое связывание  

Паттерн  
``` 
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
};

var bar = function () {
  foo.call(obj);
};
bar();
setTimeout(bar, 100);

bar.call(window);
``` 

156 - 157 
``` 
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2,
};

var bar = function () {
  return foo.apply(obj, arguments);
};

var b = bar(3); // 2 3
console.log(b); // 5
``` 

Др способ 
``` 
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

function bind(fn, obj) {
  return function () {
    return fn.apply(obj, arguments);
  };
}

var obj = {
  a: 2,
};

var bar = bind(foo, obj);
var b = bar(3); // 2 3
console.log(b); // 5
``` 

Лучший способ  
``` 
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2,
};

var bar = foo.bind(obj);

var b = bar(3);
console.log(b); // 5

``` 

bind(..) возвращает новую функ, жестко запрограмированную для вызова исх функ с заданным вами контекстом this.

'Контексты' вызовов API  
новые функ и среды поодерживают необях параметр(context), который явно связывает this
``` 
function foo(el) {
  console.log(el, this.id);
}

var obj = {
  id: "awesome",
};
[1, 2, 3].forEach(foo, obj);
``` 

### 4 **Связывание new**  

Конструкторы - обычн функ, которые вызываются с указанием оператора new перед ними. Они не присоединяются к классам и не создают их экземпляра.  

Когда функ вызывается после оператора new(такие вызовы наз вызовами-конструкторами),вып след действия:  
- создаётся новый объект
- производится связывние сконструированного объекта с [[Prototype]]
- сконструированный объект назначается в качестве связывания this для этого вызова функции 
- если функция не возврщ свой альтернатиынй объект, вызов функции авт возвращает сконструированный объект.

код
``` 
function foo(a) {
  this.a = a;
}

var bar = new foo(2);
console.log(bar.a); // 2

```

Вызывая foo(..) после new, мы конструируем новый объект и назначаем его в качестве значения this для вызова foo(..).Итак, new - последний способ связывания this для вызова функ.

Приоритеты

1 Связывание new  
исп только что сконструированный объект  
2 Явное связывание  (obj1.foo.call(obj2)  
Исп заданный объект  
3 Неявное связывание  (obj1.foo())  
Исп этот контекстный объект  
4 Связывание по умолчанию(исп DMZ объект)
По умолчанию:undefined в режиме strict, глоб объект в противном случае 


### Определение this  

1. Функция вызвана с new(**связывние new**)? Если да, то this содержит новый сконструированный объект.  
  var bar = new foo()  

2. Функция вызвана call или apply(явное связывание), даже скрытыми в жесткой  привязке bind? Если да, то  this содержит  
явно заданный объект.  
var bar = foo.call(obj2)  

3. Функция вызвана с контекстом(неявное связывание), также называемым объектом-владельцем или содержащим объектом?  
Eсли да, то this содержит контекстный объект.  
var bar = obj1.foo()  

4. В остальных случаях исп this по умолчанию (**привязка по умолчанию**). Если дествует strict, выбирается unefined, а если нет - глобальный объект:  
var bar = foo()

Исключение если в call & apply & bind передать null & undefined, то будет **связывание по умолчанию**, а также косвенный ссылки  

Существует **мягкое связывние 171 - 172 не рассмотрено.

### Лексическое поведение this  

стрелочные функции принимают связывание this от внешней обл вид(функ или глоб). Лексическое связывание стрелочной функ не может быть переопределено даже с  new. (175)
 
 
 ### Итоги  
 
 Чтобы определить связывние **this**  для вып функции,  необходимо найти непосредственное место вызова этой функции.  
 Потом применяются 4 рассмотренных правила.
 
 ##  <a name="7"></a> 7 Объекты   
 
 Оьъекты существуют в 2-ух формах **декларативный(литеральный)** и **сконструированный**  
 **Литеральный** 
 ```
 var myObj = {
 key:value
 // ...
 }
 ```
 **Сконструированный** 
  ```
  var myObj = new Object();
  myObj.key = value;  
   ```
   Единственное различие заключается в том, что в литеральном объявлении можно добавить одну или несколько  пар ключ/значение, тогда как в сконструированной форме  
   свойства должны добавляться по одному.  
   
   Сложные примитивы function & arr  
   
   ### Встроенные объекты  
   
 String Number Boolean Object Function Array Date RegExp Error     (Встроенные функции)  
 Каждая из **встроенных функций**  может использоваться как конструктор(то есть вызов функции с оператором new), результатом вызова которого явл создание  
 объекта заданного подтипа.  
 
 string number boolean  существует объектная обёртка  
 null undefined не существует  
 
 ### Содержимое  
 
 Содержимое объекта состоит из значений, хранимых в **свойствах** - областях памяти, которым присвоены имена.  
 **Важный момент**: термин **содержимое** вроде бы подразумевает, что значения хранятся внутри объекта, но это лишь иллюзия.  
 Способ хранения зависит от реализации, и данные вполне могут храниться за пределами объекта-контейнера.  
 В контейнере хранятся имена свойств, которые работают как ссылки на место хранения значений.  
myObject.a     -  точечная форма записи( обращение только  по  совместимый identifier)
myObject["a"]  -  обращение к ключу(скобочная форма записи) (практически любой UTF-8 или выражение)

В объектах имена свойств всегда строки, все остальные типы преобразуюстя в string

### Дублирвоание оьъектов

**Поверхностное**(ссылки) или **глубокое**(создание копий)

JSON  
var newObj = JSON.parse(Json.stringify(someObj))

Поверх копир(Object.assign()) - получает в 1-ом параметре объект-приёмник, а востальных параматрах - один или несколько объектов источников. Функ перебирает все перечисляемые,  
непосредственно существующие ключи объекта-источника и копирует их(посредством обычного присваивания =) в приемник  

**Дескрипторы свойств**  

**Дескриптор свойства* – это обычный JavaScript-объект, описывающий атрибуты и значение свойства.  
Анализировать характеристики свойств - значит узнать доступно свойство только для чтения или нет.  
Начиная с ES5 все свойства описываются дескрипторами свойств.
 ```
var obj = {
  a: 2,
};

console.log(Object.getOwnPropertyDescriptor(obj, "a"));
// {value: 2, writable: true, enumerable: true, configurable: true}
 ```
 
Дескриптор свойств(который в данном случае называется 'дескриптором данных', посколько он относится только к хранимому значению данных) для обычно свойства а  
содержит намноо больше инф, чем знач 2. Он также вкл 3 др характеристики: writable(возможность записи), enumerable(перечисляемость) и configurable(возможность настройки).  

Метод Object.defineProperty() определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.

### Writable  

Характеристика writable  опр возможность изм знач свойств    
В режиме strict - TypeError  

### Configurable   

Если свойтсво допускает настройку, вы можете изм оределение его дескриптора при помощи функции defineProperty()  
Если false, то изм его уже не удастся.  
Оператор delete (исп для удаления свойств(которые могут быть удалены) непостредственно из объекта  
delete блокируется при  false  

независимо от режима strict - TypeError  

### Enumerable  

Эта характеристика управляет тем, должно ли свойство включаться в перечисления свойств объетов(for .. in и т п)  
При false  свойство не будет включаться 

### Неизменяемость  

Объектные константы  
writable  false  
Configurable  false  

этот способ создаёт поверх неизм. Он вляет только на объект и на его непосредственные характеристики свойств. Если объект содержит ссылку на др объект, содержимое этого объекта остается изменяемым.

### Запрет расширения  

Если вы хотите запретить возможность добавления новых свойств в объект, но оставить остальные свойства объекта без имх, вызовите  
Object.preventExtensions()  
В режиме strict - TypeError  
Без режима просто неудча без выдачи ошибки. 

### Seal  

Object.seal()  создаёт **запечатанаый** объект; функция получает существующий объект и фактически вызывает для него Object.preventExtensions(), но также все  
существующие свойства получают пометку  configurable:false   

Таким образом, к объекту не только нельзя добавлять новые свойства, но и также нельзя изменять конфигурацию или удалять существующие свойства(хотя  
вы можете изм их знач). 

### Freeze  

Object.freeze() создаёт **замороженный** объект; функция получает существующий объект и фактически вызывает для него Object.seal(), но также все свойства доступа к данным получают пометку writable.false, так что их значения не могут  быть изменены. Можнно сдулать глубокую заморозку смотреть 200.

### [[Get]]  
для получения значения
 ```
var obj = {
  a: 2,
};
console.log(obj.a);
 ```  
 
 Этот фрагмент выполняет операцию   [[Get]] ```([[Get]]()) ```  для  obj  
 Встроенная операция по умолчанию [[Get]] у объекта сначала ищет в объекте свойство с указанным именем, и если оно будет найдено - возвращает соответствующее значение.  
 При это он обходит цепочки [[prototype]]  
 Если этой операции не удается получить запрашиваемое значение то мы получаем undefined.  
 
 Это поведение отличвется от обращения к переменным по именам иденитфикаторов. При обращении к пер, которую не удается разрешить соответствующим поиском лекс обл вид,  
 вы не получаете результат undefined, как при обращении к своствам объекта; вместо этого ReferenceError.
 
 ### [[Put]]  
 
 для записи или создания свойства в каз объекте.
 
 Если свойство присутсвует, алгоритм [[Put]] проверяет следующие:  
 - является ли свойство дескриптором функции доступа? В атком случае вызывается set-функция, если она существует  
 - свойство явл дескриптором данных с характеристикой writable:false? В таком случае при отсутсвии режима strict происходит незаметный сбой, а в режиме  strict  выдается ошбка TypeError  
 - в остальных случаях занчение присваивается существующему свойству, как обычно.
 
  ### Геттеры  и сеттеры  
  
  [[Get]] и [[Put]] для объектов полностью управляют присваиванием значений сущестующим или новым свойствам, а также чтением из существующих свойств  
  
  Геттеры - свйоства, которые вызывают скрытую функцию для получения нужного значения.  
  Сеттеры - свойства, которые вызывают скрытую функцию для присваивания значепния.  
  
  Когда мы опр дял свойства геттер и/ или сеттер, его поределение становится **дескриптором методов доступа**( в отличие от **дескриптора данных**).Для дескрипторов методов доступа характеристики  value & writable дескриптора считаются несущественными и игнорируются, а JS учитывает только характеристики set  и get свойства( а также  
  configurable & enumerable).

При исп синтаксиса объект литералов  как с get a() {..}, так и с явным опр  definePriperty(..), в обоих случаях будет создано свойство объекта, которое на самом деле не содержит значения.Тем ре мерее при обращении к этому свойству авт вызывается скрытая функция дял геттера, и возвращенное этой функцией знач стан резулт обрщаения к свойству.  
Попытка присваивание к сеттеру ни к чему не приведёт.

### Существование  

Оператор in(првоеряет наличие свойство с заданным именем)  проверяет существует ли свойство в объекте  или на одном из более высоких уровней обхода цепочки [[Prototype]]  
hasOwnProperty(..) проверяет только объект ( эта функция доступна каждому объекту из-за делегирвоания Object.prototype)  

### Перечисление  

**propertyIsEnumerable(..)** проверяет, существует ли свойство с заданным именем непосредственно у объекта, а такэе характеристику enumerable:true  
**Object.keys(..)** возвращает массив всех перечисляемых свойств   
**Object.getOwnPropertyNames(..) возвращает массив всех свойств  

### Перебор  

forEach(..) some(..) every(..)  
Каждая функция получает функцию обратного вызова, которая будет применена к каждому элементу массива; различается только реакция на возвращаемое значение функции обратного вызова  
**forEach(..)** перебирает все значения в массиве и игнорирует возвращаемые значения  
**every(..)** продолжает переюор до конца или до того момента, когда обр вызов вернет false  
**some(..)** продолжает перебор до конца или до того моента, когда обр вызов вернет true( или **истинное** значение)  
 
Для перебора значений исп for .. of  
Цикл **for .. of** запрашивает объект-итератор(у внетренней функции по умол, которая в спец обозн @@iteraor) для того, что должно перебираться, а затем перебирает  последовательные возвращаемые значения, полученные при вызове метода next() этого объекта-итератора(по одн для каждой итерации цикла)

## <a name="8"></a> Классы  

### Теория классов  

Классы/наследование описывают определённую форму организации кода и архитектуры - способ моделирования предметных обл реального мирав в программных продуктах.  
**ООП** основано на том, что с данными по их природе связывается некоторое поведение, которое с этими данными работает.  
Таким образом, в процессе проектирвания данные упаковываются(инкапсулирруются) вместе с поведением.  
Иногда это  назывется **структурой данных**  

У нас есть строка состоящая из букв  с которой мы имеем возможность выполнять различные операции, поэтому различные аспекты поведения, которые могут применяться к этим данным оформляются в виде методов класса String.  
Любая конкретная строка представляет собой экземпляр этого класса - аккуратный пакет, состоящий как из символьных данных, так и из функциональности, которая к ним применяется.

Классы также подразумевают определенный механизм классификации структуры данных. Для этого любая заданная структура данных рассматривается как частный случай более общего базового определения.  

**Полиформизм** - описывает концепцию того, что общее поведение родительского класса может переопределяться в дочернем классе для определения более конкретной реализации.  
Относительный полиформизм позволяет обращаться к базовому поведению ищъз переопределенного поведения.  

**Класс** - это план по которому ведется строительство.  

Чтобы получить объект, с которым можно взаимодействовать, необходимо создать экземпляр(построить) на основе класса.  
Конечный итог это объект наз  **экземпляром**  
Этот объект явл копией характеристик, описываемых классом.  

### **Конструктор**  

Экземпляры классов крнструируются спец методом класса, имя которого обычно совпадает с именем класса. Этот метод наз **конструктором**  
Его непосредственная задача - инициализация любой инф(состояния), необходимой экземпляру.  
Конструкторы почти всегда должны вызываться с опер new, чтобы языковое ядро понимало, что вы хотите сконструировать новый экземпляр класса.

### **Наследование**

### Итоги  

Классы явл паттерном проектирования.Многие языки представлют синтаксис, который делает возможным естественное проектирование программного кода, ориентированное на исп классов.  
Классы подразумевают копирование.  
При создании  экземпляра традиционных классов происходит копирование поведения из класса в экземпляр.При наследовании классов также происходит копирование поведения из родителей в потомока.  
Может показаться, что **Полиформизм**(существование разных функций с одинаковыми именами на разных уровнях цепочки наследования) подразумевает наличие относительной связи по ссылки потомка к родителю, но в действительности он всего лишь явл результатом копирования. 

Паттерн **Примесь**(явный и неявный) часто исп для моделирования поведения копирования классов, но обычно он ведет к  уродливому и ненадёжному синтаксису, например явному псвевдополиформизму(OtherObj.methodName.call(this, ....)), что часто приводит к созданию кода, более сложного для понимания и сопровождения.  

Явные примеси тоже не совсем точно воспроизводят поведение копирования классов, так как дял объектов(и функций) коп только общие ссылки, а не сами объекты/функ. На такие нюансы необходимо обращать внимание, иначе они станут источником всевозможных проблем.

Прочит 229 - 230  

### Примеси  

https://learn.javascript.ru/mixins


## <a name="9"></a> Прототипы  

У объектов JS имеется внутр свойство, обознач в спец [[Prototype]]; в нем хранится обычная ссылка на др объект.Почти у всех объектов в момент их создания этому свойству присваивается значение, отличное от null.  

Операция[[Get]], которая вызывается при обращении к свойству объекта(например,myObject.a).При выполнении операции [[Get]] по умолчанию прежде всего проверяется, содержит ли сам объект свойство a, и если содержит - то оно используется.  
Если операция [[Get]] по умолчанию не может найти запрашиваемое свойство непосредвственно в объекте, она переходит по ссылке [[Prototype]] объекта, а если и там ничего не будет найдено, то возвращается undefined.  

### Object.prototype  

Имеет разнообразные стандартные возможности(функциональность). Например:  
String() & .valueOf() ...


myObject.foo = 'bar';  
Если объект myObject уже содержит нормальные свойство доступа к данным с именем foo(то есть свойство находится неопсредственно вобъекте), присваивание ограничивается простым изменением значения существующего  свойства.  

Если foo не присутствует непосредственно в myObject, происходит обход цепочки [[Prototype]], как при операции [[Get]]. Если foo не удается найти нигде в цепочке, свойство  foo  
добавляется прямо в myObject с заданным значением, как и следовало ожидать.

Объекты связаны друг с другом  ссылкой[[Prototype]]  
Суть [[Prototype]] заключается в создании связей между объектами.

**Интроспкция** - анализ экземпляра(просто объекта JS) на предмет иерархии наследования(связей делегирования в JS) часто называется интроспекцией(отражением или рефлексией).  
**Цепочка прототипов** - последовательная связь между объектами.

Свойство **._proto_** получает внутренее свойство [[Prototype]] объекта  в виде  ссылки. 

### Создание связей вызовом Create()  
Object.create(..) создает новый объект, связанный с заданным объектом.  
Таким образом, мы получаем всю мощь механизма [[Prototype]] (делегирование), но без функции new, моделирующих классы, вызовов конструкторов, непонятных ссылок .prototype и  
.constructor, а также прочих ненужных сложностей.

### Итоги  

При попытке обращения к  свойству для объекта, у которогу  этого свойтсво отсутствует, внутренняя связь [[Prototype]] объекта определяет, где операция [[Get]] должна продолжить поиск. Система каскадных ссылок между объектами фактически определяет **цепочку прототипов** объектов, которые должны перебираться при разрешении свойства.  

На вершине обычно находиться Object.prototype(аналог глоб обл вид)  
Один из способ связывание - это  new

В JS копирование не производится. Вместо этого объекты связываются друг с другом по внутренней цепочке [[Prototype]] (делегирование).

## <a name="10"></a> 10 Делегирование поведения
