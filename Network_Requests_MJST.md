# Network_Requests_MJST

Содержание   
[2 Промисы ](#2)  
[3 Цепочка промисов](#3)  
[4 Промисы: обработка ошибок](#4)  
[5 Promise API ](#5)  
[6 Промисификация ](#6)  
[7 Микрозадачи ](#7)  
[8 Async/await](#8)

[Формат JSON, метод toJSON](#JSON)

[1 Fetch](#9)  
[2 FormData](#10)  
[3 Fetch: ход загрузки](#11)  
[4 Fetch: прерывание запроса](#12)  
[5 Fetch: запросы на другие сайты](#13)  
[6 Fetch API](#14)  
[7 Объекты URL](#15)  
[8 XMLHttpRequest](#16)  

[1 Куки, document.cookie](#17)  
[2 LocalStorage, sessionStorage](#18)  
[3 IndexedDB](#19)




## Промисы, async/await

## <a name="2"></a>2 Промисы

В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая будет вызвана по завершению асинхронного действия.  
Каждое новое действие мы вынуждены вызывать внутри колбэка. Этот вариант подойдёт, когда у нас одно-два действия, но для большего количества уже не удобно. Альтернативные подходы мы скоро разберём.

**Promise** – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе.  
промис делает результат доступным для кода, который подписан на него, когда результат готов.

Синтксис  

```
let promise = new Promise(function(resolve, reject) {  
//функция-исполнитель (executor)  
//"певец"
});

```

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически.  
Она должна содержать «создающий» код,  который когда-нибудь создаст результат.

Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.  
Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:  
resolve(value) — если работа завершилась успешно, с результатом value.  
reject(error) — если произошла ошибка, error – объект ошибки.  
Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:  
state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при  
вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.  
result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

Так что исполнитель по итогу переводит promise в одно из двух состояний:
![Screenshot_2](https://user-images.githubusercontent.com/66359081/117813793-31ffec80-b26c-11eb-9ebf-a34a9709660c.png)

```
let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});

```

Мы можем наблюдать две вещи, запустив код выше:

Функция-исполнитель запускается сразу же при вызове new Promise.
Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать.  
Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.

Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат:

![Screenshot_1](https://user-images.githubusercontent.com/66359081/118006244-c5f8b380-b353-11eb-9d1f-96061ef73a6a.png)

Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.
А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:

```
let promise = new Promise(function(resolve, reject) {
  // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

```

![Screenshot_3](https://user-images.githubusercontent.com/66359081/118006437-ecb6ea00-b353-11eb-8b1f-2b3b3b14ed2d.png)

Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает resolve или reject,  
чтобы изменить состояние соответствующего Promise.
Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».

### Потребители: then, catch, finally

Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then, .catch и .finally.

###then  
Наиболее важный и фундаментальный метод – .then.  
Синтаксис:

```
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);

```

Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.  
Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.  
Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:

```
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // выведет "done!" спустя одну секунду

```

### catch  
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:

```
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это тоже самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```

Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).

### finally

По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.  
Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.  
finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.

## <a name="3"></a>3 Цепочка промисов

promise.then тоже возвращает промис, так что мы можем вызвать на нём следующий .then.
Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий .then.

### Итого  
Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит,  
результат  его выполнения (или ошибка) передаётся дальше.

Вот полная картина происходящего:  
![Screenshot_4](https://user-images.githubusercontent.com/66359081/118112338-8ed6e080-b3ed-11eb-80f2-8fa6be4de5ff.png)  

## <a name="4"></a>4 Промисы: обработка ошибок

Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это очень удобно.  
Например, в представленном ниже примере для fetch указана неправильная ссылка (сайт не существует), и .catch перехватывает ошибку:  
```
fetch('https://no-such-server.blabla') // ошибка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
```  
Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки

### Неявный try…catch  

Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.  
"Невидимый try..catch" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.  

### Итого 

 .catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.  
 Необходимо размещать .catch там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (могут быть полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (возможно, это программная ошибка).  
 Можно и совсем не использовать .catch, если нет нормального способа восстановиться после ошибки.  
 В любом случае нам следует использовать обработчик события unhandledrejection (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».
 
 ## <a name="5"></a>5 Promise API 
 
 В классе Promise есть 5 статических методов. Давайте познакомимся с ними.  
 
 ### Итого  
 
Мы ознакомились с пятью статическими методами класса Promise:
Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами.  
Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.  
Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.  
Например, Promise.all, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив [1, 2, 3]:  
```  
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
```  
Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.  
Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.  
Promise.allSettled(promises) (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:  
state: "fulfilled", если выполнен успешно или "rejected", если ошибка,  
value – результат, если успешно или reason – ошибка, если нет.  
Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.  
Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.  
```
let promise = new Promise(resolve => resolve(value));  
```
Promise.reject(error) – возвращает промис с ошибкой error.  
```
let promise = new Promise((resolve, reject) => reject(error));
```
Из всех перечисленных методов, самый часто используемый – это, пожалуй, Promise.all.

## <a name="6"></a>6 Промисификация 

Промисификация – это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.  
Такие преобразования часто необходимы в реальной жизни, так как многие функции и библиотеки основаны на колбэках, а использование промисов более удобно, поэтому есть смысл  
«промисифицировать» их.  
Например, у нас есть loadScript(src, callback) из главы Введение: колбэки.  
```
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}

// использование:
// loadScript('path/script.js', (err, script) => {...})
```

Давайте промисифицируем её. Новая функция loadScriptPromise(src) будет делать то же самое, но будет принимать только src (не callback) и возвращать промис.  

```
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}

// использование:
// loadScriptPromise('path/script.js').then(...)
```

Теперь loadScriptPromise хорошо вписывается в код, основанный на промисах.  
Как видно, она передаёт всю работу исходной функции loadScript, предоставляя ей колбэк, по вызову которого происходит resolve/reject промиса.  
На практике нам, скорее всего, понадобится промисифицировать не одну функцию, поэтому имеет смысл сделать для этого специальную «функцию-помощник».  
Мы назовём её promisify(f) – она принимает функцию для промисификации f и возвращает функцию-обёртку.  

На заметку:  
Промисификация – это отличный подход, особенно, если вы будете использовать async/await (см. следующую главу), но она не является тотальной заменой любых колбэков.  
Помните, промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.  
Поэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка будут проигнорированы.

## <a name="7"></a>7 Микрозадачи 
 
 Обработчики промисов .then/.catch/.finally всегда асинхронны.  
 Даже когда промис сразу же выполнен, код в строках ниже .then/.catch/.finally будет запущен до этих обработчиков.
 ```
 let promise = Promise.resolve();
promise.then(() => alert("промис выполнен"));
alert("код выполнен"); // этот alert показывается первым]
```

Если вы запустите его, сначала вы увидите код выполнен, а потом промис выполнен.  
Это странно, потому что промис определённо был выполнен с самого начала.  
Почему .then срабатывает позже? Что происходит?


**Очередь микрозадач**

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs, более известную как «очередь микрозадач (microtask queue)» (термин V8).  
Как сказано в спецификации:  
Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.  
Выполнение задачи происходит только в том случае, если ничего больше не запущено.  
Или, проще говоря, когда промис выполнен, его обработчики .then/catch/finally попадают в очередь. Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет 
её, когда он освободится от выполнения текущего кода.

### Итого
Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs», так называемую «очередь микрозадач (microtask queue)» (термин 
v8).  
Таким образом, обработчики .then/catch/finally вызываются после выполнения текущего кода.  
Если нам нужно гарантировать выполнение какого-то кода после .then/catch/finally, то лучше всего добавить его вызов в цепочку .then.  
В большинстве движков JavaScript, включая браузеры и Node.js, микрозадачи тесно связаны с так называемым «событийным циклом» и «макрозадачами». Так как они не связаны напрямую  
промисами, то рассматриваются в другой части учебника, в главе Событийный цикл: микрозадачи и макрозадачи.

## <a name="8"></a>8 Async/await


### Асинхронные функции
```
async function f() {
  return 1;
}
```

У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.  
Например, эта функция возвратит выполненный промис с результатом 1:  
```
async function f() {
  return 1;
}

f().then(alert); // 1
```

## Await  
```
// работает только внутри async–функций
let value = await promise;
```

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.  
В этом примере промис успешно выполнится через 1 секунду:
```
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
```

В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».  
По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.

### Обработка ошибок

Когда промис завершается успешно, await promise возвращает результат. Когда завершается с ошибкой – будет выброшено исключение. Как если бы на этом месте находилось выражение throw.

Но есть отличие: на практике промис может завершиться с ошибкой не сразу, а через некоторое время. В этом случае будет задержка, а затем await выбросит исключение.  
Такие ошибки можно ловить, используя try..catch, как с обычным throw:
```
async function f() {

  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}

f();
```  
В случае ошибки выполнение try прерывается и управление прыгает в начало блока catch. Блоком try можно обернуть несколько строк

### Итого

Ключевое слово async перед объявлением функции:  
Обязывает её всегда возвращать промис.  
Позволяет использовать await в теле этой функции.  
Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:  
Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.  
Иначе вернётся результат промиса.  
Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.  
Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await 
отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.

## <a name="JSON"></a>Формат JSON, метод toJSON

### JSON.stringify  
JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов.  
JSON легко использовать для обмена данными, когда клиент использует JavaScript, а сервер написан на Ruby/PHP/Java или любом другом языке.  
JavaScript предоставляет методы:  
JSON.stringify для преобразования объектов в JSON.  
JSON.parse для преобразования JSON обратно в объект.

пример, здесь мы преобразуем через JSON.stringify данные студента:
``` 
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // мы получили строку!

alert(json);
/* выведет объект в формате JSON:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
``` 

Метод JSON.stringify(student) берёт объект и преобразует его в строку.  
Полученная строка json называется JSON-форматированным или сериализованным объектом. Мы можем отправить его по сети или поместить в обычное хранилище данных.  
Обратите внимание, что объект в формате JSON имеет несколько важных отличий от объектного литерала:  
Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так 'John' становится "John".  
Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так age:30 становится "age":30.  
JSON.stringify может быть применён и к примитивам.  
JSON поддерживает следующие типы данных:  
Объекты { ... }  
Массивы [ ... ]  
Примитивы:  
строки,  
числа,  
логические значения true/false,  
null.

JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.  
А именно:  
Свойства-функции (методы).  
Символьные свойства.  
Свойства, содержащие undefined.
``` 
let user = {
  sayHi() { // будет пропущено
    alert("Hello");
  },
  [Symbol("id")]: 123, // также будет пропущено
  something: undefined // как и это - пропущено
};

alert( JSON.stringify(user) ); // {} (пустой объект)
```   
Важное ограничение: не должно быть циклических ссылок.

## Исключаем и преобразуем: replacer

Полный синтаксис JSON.stringify:
```
let json = JSON.stringify(value[, replacer, space])
```
**value** - Значение для кодирования.  
**replacer** - Массив свойств для кодирования или функция соответствия function(key, value).  
**space** - Дополнительное пространство (отступы), используемое для форматирования

В большинстве случаев JSON.stringify используется только с первым аргументом. Но если нам нужно настроить процесс замены, например, отфильтровать циклические ссылки, то можно использовать второй аргумент JSON.stringify.

Если мы передадим ему массив свойств, будут закодированы только эти свойства.
```
Например:
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}
```
Здесь мы, наверное, слишком строги. Список свойств применяется ко всей структуре объекта. Так что внутри participants – пустые объекты, потому что name нет в списке.
```
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
```
Теперь всё, кроме occupiedBy, сериализовано. Но список свойств довольно длинный.  
К счастью, в качестве replacer мы можем использовать функцию, а не массив.  
Функция будет вызываться для каждой пары (key, value), и она должна возвращать заменённое значение, которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.В нашем случае мы можем вернуть value «как есть» для всего, кроме occupiedBy. Чтобы игнорировать occupiedBy, код ниже возвращает undefined:
```
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* пары ключ:значение, которые приходят в replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
```

Обратите внимание, что функция replacer получает каждую пару ключ/значение, включая вложенные объекты и элементы массива. И она применяется рекурсивно. Значение this внутри replacer – это объект, который содержит текущее свойство.  
Первый вызов – особенный. Ему передаётся специальный «объект-обёртка»: {"": meetup}. Другими словами, первая (key, value) пара имеет пустой ключ, а значением является целевой  объект в общем. Вот почему первая строка из примера выше будет ":[object Object]".  
Идея состоит в том, чтобы дать как можно больше возможностей replacer – у него есть возможность проанализировать и заменить/пропустить даже весь объект целиком, если это необходимо.

### Форматирование: space  

Третий аргумент в JSON.stringify(value, replacer, space) – это количество пробелов, используемых для удобного форматирования.  
Параметр space применяется для логирования и красивого вывода.

### Пользовательский «toJSON»   

Как и toString для преобразования строк, объект может предоставлять метод toJSON для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.  
давайте добавим собственную реализацию метода toJSON в наш объект room (2):
```
let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
Как видите, toJSON используется как при прямом вызове JSON.stringify(room), так и когда room вложен в другой сериализуемый объект.
```

### JSON.parse  

Чтобы декодировать JSON-строку, нам нужен другой метод с именем JSON.parse.  
Синтаксис:
```
let value = JSON.parse(str, [reviver]);
```
str
JSON для преобразования в объект.
reviver
Необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение.
Например:
```
// строковый массив
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
```

Или для вложенных объектов:
```
let user = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

user = JSON.parse(user);

alert( user.friends[1] ); // 1
```  
Добавление комментария в JSON делает его недействительным.

###  Итого  
JSON – это формат данных, который имеет собственный независимый стандарт и библиотеки для большинства языков программирования.  
JSON поддерживает простые объекты, массивы, строки, числа, логические значения и null.  
JavaScript предоставляет методы JSON.stringify для сериализации в JSON и JSON.parse для чтения из JSON.  
Оба метода поддерживают функции преобразования для интеллектуального чтения/записи.  
Если объект имеет метод toJSON, то он вызывается через JSON.stringify.

## <a name="Fetch"></a>1 Fetch

JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере необходимости.

Например, мы можем использовать сетевой запрос, чтобы:  
Отправить заказ,  
Загрузить информацию о пользователе,  
Запросить последние обновления с сервера,  
…и т.п.  
Для сетевых запросов из JavaScript есть широко известный термин «AJAX» (аббревиатура от Asynchronous JavaScript And XML).

Метод fetch()
```  
let promise = fetch(url, [options])
```  

url – URL для отправки запроса.  
options – дополнительные параметры: метод, заголовки и так далее.  
Без options это простой GET-запрос, скачивающий содержимое по адресу url.  
Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.

**Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.**  
На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.  
Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.  
Мы можем увидеть HTTP-статус в свойствах ответа:  
status – код статуса HTTP-запроса, например 200.  
ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.

**Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.**  
Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:  
response.text() – читает ответ и возвращает как обычный текст,  
response.json() – декодирует ответ в формате JSON,  
response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),  
response.blob() – возвращает объект как Blob (бинарные данные с типом),  
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),  
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.

**Важно:**  
Мы можем выбрать только один метод чтения ответа.  
Если мы уже получили ответ с response.text(), тогда response.json() не сработает, так как данные уже были обработаны.

Заголовки ответа  
Заголовки ответа хранятся в похожем на Map объекте response.headers.  
Заголовки запроса  
Для установки заголовка запроса в fetch мы можем использовать опцию headers. Она содержит объект с исходящими заголовками, например:
``` 
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});
``` 

### POST-запросы

Для отправки POST-запроса или запроса с другим методом, нам необходимо использовать fetch параметры:  
method – HTTP метод, например POST,  
body – тело запроса, одно из списка:  
строка (например, в формате JSON),  
объект FormData для отправки данных как form/multipart,  
Blob/BufferSource для отправки бинарных данных,  
URLSearchParams для отправки данных в кодировке x-www-form-urlencoded, используется редко.  
Чаще всего используется JSON.  

### Отправка изображения

Мы можем отправить бинарные данные при помощи fetch, используя объекты Blob или BufferSource.

### Итого

Типичный запрос с помощью fetch состоит из двух операторов await:
``` 
let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON
``` 

Или, без await:
``` 
fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
  ``` 
  
Параметры ответа:

response.status – HTTP-код ответа,  
response.ok – true, если статус ответа в диапазоне 200-299.  
response.headers – похожий на Map объект с HTTP-заголовками.  
Методы для получения тела ответа:  
response.text() – возвращает ответ как обычный текст,  
response.json() – преобразовывает ответ в JSON-объект,    
response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),  
response.blob() – возвращает объект как Blob (бинарные данные с типом),  
response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),  
Опции fetch, которые мы изучили на данный момент:  
method – HTTP-метод,  
headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),  
body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.



## <a name="10"></a>2 FormData

это объект, представляющий данные HTML формы.

Конструктор:
``` 
let formData = new FormData([form]);
``` 

Если передать в конструктор элемент HTML-формы form, то создаваемый объект автоматически прочитает из неё поля.  
Его особенность заключается в том, что методы для работы с сетью, например fetch, позволяют указать объект FormData в свойстве тела запроса body.  
Он будет соответствующим образом закодирован и отправлен с заголовком Content-Type: form/multipart.  
То есть, для сервера это выглядит как обычная отправка формы.
``` 
<form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
``` 

### Методы объекта FormData

С помощью указанных ниже методов мы можем изменять поля в объекте FormData:

formData.append(name, value) – добавляет к объекту поле с именем name и значением value,  
formData.append(name, blob, fileName) – добавляет поле, как будто в форме имеется элемент <input type="file">, третий аргумент fileName устанавливает имя файла (не имя поля формы), как будто это имя из файловой системы пользователя,  
formData.delete(name) – удаляет поле с заданным именем name,  
formData.get(name) – получает значение поля с именем name,  
formData.has(name) – если существует поле с именем name, то возвращает true, иначе false

Технически форма может иметь много полей с одним и тем же именем name, поэтому несколько вызовов append добавят несколько полей с одинаковыми именами.

Ещё существует метод set, его синтаксис такой же, как у append. Разница в том, что .set удаляет все уже имеющиеся поля с именем name и только затем добавляет новое. То есть этот метод гарантирует, что будет существовать только одно поле с именем name, в остальном он аналогичен .append:
``` 
formData.set(name, value),
formData.set(name, blob, fileName).
Поля объекта formData можно перебирать, используя цикл for..of:

let formData = new FormData();
formData.append('key1', 'value1');
formData.append('key2', 'value2');

// Список пар ключ/значение
for(let [name, value] of formData) {
  alert(`${name} = ${value}`); // key1=value1, потом key2=value2
}
``` 

### Отправка формы с файлом

Объекты FormData всегда отсылаются с заголовком Content-Type: form/multipart, этот способ кодировки позволяет отсылать файлы. Таким образом, поля <input type="file"> тоже отправляются, как это и происходит в случае обычной формы.

### Отправка формы с Blob-данными

----


### Итого 

Объекты FormData используются, чтобы взять данные из HTML-формы и отправить их с помощью fetch или другого метода для работы с сетью.  
Мы можем создать такой объект уже с данными, передав в конструктор HTML-форму – new FormData(form), или же можно создать объект вообще без формы и затем добавить к нему поля с помощью методов:  
formData.append(name, value)  
formData.append(name, blob, fileName)  
formData.set(name, value)  
formData.set(name, blob, fileName)  
Отметим две особенности:  
Метод set удаляет предыдущие поля с таким же именем, а append – нет. В этом их единственное отличие.  
Чтобы послать файл, нужно использовать синтаксис с тремя аргументами, в качестве третьего как раз указывается имя файла, которое обычно, при <input type="file">, берётся из файловой системы.  
Другие методы:  
formData.delete(name)  
formData.get(name)  
formData.has(name)

## <a name="11"></a>3 Fetch: ход загрузки

Метод fetch позволяет отслеживать процесс получения данных.  
Заметим, на данный момент в fetch нет способа отслеживать процесс отправки. Для этого используйте XMLHttpRequest, позже мы его рассмотрим.

Чтобы отслеживать ход загрузки данных с сервера, можно использовать свойство response.body. Это ReadableStream («поток для чтения») – особый объект, который предоставляет тело ответа по частям, по мере поступления. Потоки для чтения описаны в спецификации Streams API.  
В отличие от response.text(), response.json() и других методов, response.body даёт полный контроль над процессом чтения, и мы можем подсчитать, сколько данных получено на каждый момент.  
Вот примерный код, который читает ответ из response.body:
``` 
// вместо response.json() и других методов
const reader = response.body.getReader();

// бесконечный цикл, пока идёт загрузка
while(true) {
  // done становится true в последнем фрагменте
  // value - Uint8Array из байтов каждого фрагмента
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Получено ${value.length} байт`)
}
``` 
Результат вызова await reader.read() – это объект с двумя свойствами:  
done – true, когда чтение закончено, иначе false.  
value – типизированный массив данных ответа Uint8Array.  

Вот полный рабочий пример, который получает ответ сервера и в процессе получения выводит в консоли длину полученных данных:
``` 
// Шаг 1: начинаем загрузку fetch, получаем поток для чтения
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Шаг 2: получаем длину содержимого ответа
const contentLength = +response.headers.get('Content-Length');

// Шаг 3: считываем данные:
let receivedLength = 0; // количество байт, полученных на данный момент
let chunks = []; // массив полученных двоичных фрагментов (составляющих тело ответа)
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Получено ${receivedLength} из ${contentLength}`)
}

// Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Шаг 5: декодируем Uint8Array обратно в строку
let result = new TextDecoder("utf-8").decode(chunksAll);

// Готово!
let commits = JSON.parse(result);
alert(commits[0].author.login);
``` 

Разберёмся, что здесь произошло:  
Мы обращаемся к fetch как обычно, но вместо вызова response.json() мы получаем доступ к потоку чтения response.body.getReader().  
Обратите внимание, что мы не можем использовать одновременно оба эти метода для чтения одного и того же ответа: либо обычный метод response.json(), либо чтение потока response.body.  
Ещё до чтения потока мы можем вычислить полную длину ответа из заголовка Content-Length.  
Он может быть нечитаемым при запросах на другой источник (подробнее в разделе Fetch: запросы на другие сайты) и, в общем-то, серверу необязательно его устанавливать. Тем не менее, обычно длина указана.  
Вызываем await reader.read() до окончания загрузки.  
Всё, что получили, мы складываем по «кусочкам» в массив chunks. Это важно, потому что после того, как ответ получен, мы уже не сможем «перечитать» его, используя response.json() или любой другой способ (попробуйте – будет ошибка).  
В самом конце у нас типизированный массив – Uint8Array. В нём находятся фрагменты данных. Нам нужно их склеить, чтобы получить строку. К сожалению, для этого нет специального метода, но можно сделать, например, так:  
Создаём chunksAll = new Uint8Array(receivedLength) – массив того же типа заданной длины.  
Используем .set(chunk, position) для копирования каждого фрагмента друг за другом в него.  
Наш результат теперь хранится в chunksAll. Это не строка, а байтовый массив.  
Чтобы получить именно строку, надо декодировать байты. Встроенный объект TextDecoder как раз этим и занимается. Потом мы можем, если необходимо, преобразовать строку в данные с помощью JSON.parse.  
Что если результат нам нужен в бинарном виде вместо строки? Это ещё проще. Замените шаги 4 и 5 на создание единого Blob из всех фрагментов:  
let blob = new Blob(chunks);  
В итоге у нас есть результат (строки или Blob, смотря что удобно) и отслеживание прогресса получения.  
На всякий случай повторимся, что здесь мы рассмотрели, как отслеживать процесс получения данных с сервера, а не их отправки на сервер. Для отслеживания отправки у fetch пока нет способа.


 
## <a name="12"></a>4 Fetch: прерывание запроса

Как мы знаем, метод fetch возвращает промис. А в JavaScript в целом нет понятия «отмены» промиса. Как же прервать запрос fetch?  
Для таких целей существует специальный встроенный объект: AbortController, который можно использовать для отмены не только fetch, но и других асинхронных задач.  
Использовать его достаточно просто:  
Шаг 1: создаём контроллер:
``` 
let controller = new AbortController();
``` 
Контроллер controller – чрезвычайно простой объект.  
Он имеет единственный метод abort() и единственное свойство signal.  
При вызове abort():  
генерируется событие с именем abort на объекте controller.signal  
свойство controller.signal.aborted становится равным true.  
Все, кто хочет узнать о вызове abort(), ставят обработчики на controller.signal, чтобы отслеживать его.

AbortController – масштабируемый, он позволяет отменить несколько вызовов fetch одновременно.

## <a name="13"></a>5 etch: запросы на другие сайты
## <a name="14"></a>6 Fetch API


## <a name="17"></a>1 Куки, document.cookie

Куки – это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола, определённого в спецификации RFC 6265.  
Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.  

Один из наиболее частых случаев использования куки – это аутентификация:  
При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).  
Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.  
Таким образом, сервер понимает, кто сделал запрос.  
Мы также можем получить доступ к куки непосредственно из браузера, используя свойство document.cookie.

### Чтение из document.cookie
Хранит ли ваш браузер какие-то куки с этого сайта? Посмотрим:
```
// На javascript.info мы используем сервис Google Analytics для сбора статистики,
// поэтому какие-то куки должны быть
alert( document.cookie ); // cookie1=value1; cookie2=value2;...
```  
Значение document.cookie состоит из пар ключ=значение, разделённых ;. Каждая пара представляет собой отдельное куки.

Чтобы найти определённое куки, достаточно разбить строку из document.cookie по ;, и затем найти нужный ключ. Для этого мы можем использовать как регулярные выражения, так и функции для обработки массивов.  

### Запись в document.cookie  

Мы можем писать в document.cookie. Но это не просто данные, а акcессор (геттер/сеттер). Присваивание обрабатывается особым образом.  
Запись в document.cookie обновит только упомянутые в ней куки, но при этом не затронет все остальные.  
Например, этот вызов установит куки с именем user и значением John:  
document.cookie = "user=John"; // обновляем только куки с именем 'user'  
alert(document.cookie); // показываем все куки  
Если вы запустите этот код, то, скорее всего, увидите множество куки. Это происходит, потому что операция document.cookie= перезапишет не все куки, а лишь куки с вышеупомянутым именем user.
```  
### getCookie(name)  
Самый короткий способ получить доступ к куки – это использовать регулярные выражения.  
Функция getCookie(name) возвращает куки с указанным name:

// возвращает куки с указанным name,
// или undefined, если ничего не найдено
function getCookie(name) {
  let matches = document.cookie.match(new RegExp(
    "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
  ));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}
```  
Здесь new RegExp генерируется динамически, чтобы находить ; name=<value>.  
 Обратите внимание, значение куки кодируется, поэтому getCookie использует встроенную функцию decodeURIComponent для декодирования.  
  
###  setCookie(name, value, options)  
Устанавливает куки с именем name и значением value, с настройкой path=/ по умолчанию (можно изменить, чтобы добавить другие значения по умолчанию):

### deleteCookie(name)

### Приложение: Сторонние куки

Куки называются сторонними, если они размещены с домена, отличающегося от страницы, которую посещает пользователь.

Например:  
Страница site.com загружает баннер с другого сайта: <img src="https://ads.com/banner.png">.  
Вместе с баннером удалённый сервер ads.com может установить заголовок Set-Cookie с куки, например, id=1234. Такие куки создаются с домена ads.com и будут видны только на сайте ads.com  
В следующий раз при доступе к ads.com удалённый сервер получит куки id и распознает пользователя  
Что ещё более важно, когда пользователь переходит с site.com на другой сайт other.com, на котором тоже есть баннер, то ads.com получит куки, так как они принадлежат ads.com, таким образом ads.com распознает пользователя и может отслеживать его перемещения между сайтами  
Сторонние куки в силу своей специфики обычно используются для целей отслеживания посещаемых пользователем страниц и показа рекламы. Они привязаны к исходному домену, поэтому ads.com может отслеживать одного и того же пользователя на разных сайтах, если оттуда идёт обращение к нему.

Естественно, некоторым пользователям не нравится, когда их отслеживают, поэтому браузеры позволяют отключать такие куки.

### Итого  
document.cookie предоставляет доступ к куки

операция записи изменяет только то куки, которое было указано.  
имя и значение куки должны быть закодированы.  
одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).  
Настройки куки:  
path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.  
domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.  
expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.  
secure делает куки доступным только при использовании HTTPS.  
samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.  
Дополнительно:  
Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.  
Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR

## <a name="18"></a>2 LocalStorage, sessionStorage

Что в них важно – данные, которые в них записаны, сохраняются после обновления страницы (в случае sessionStorage) и даже после перезапуска браузера (при использовании localStorage). Скоро мы это увидим.  
Но ведь у нас уже есть куки. Зачем тогда эти объекты?  
В отличие от куки, объекты веб-хранилища не отправляются на сервер при каждом запросе. Поэтому мы можем хранить гораздо больше данных. Большинство браузеров могут сохранить как  минимум 2 мегабайта данных (или больше), и этот размер можно поменять в настройках.  
Ещё одно отличие от куки – сервер не может манипулировать объектами хранилища через HTTP-заголовки. Всё делается при помощи JavaScript.  
Хранилище привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга. 

### Демо localStorage  
Основные особенности localStorage:  
Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).  
Данные не имеют срока давности, по которому истекают и удаляются. Сохраняются после перезапуска браузера и даже ОС.  
Например, если запустить этот код…  
```  
localStorage.setItem('test', 1);  
```  
…И закрыть/открыть браузер или открыть ту же страницу в другом окне, то можно получить данные следующим образом:  
```  
alert( localStorage.getItem('test') ); // 1  
```  
Нам достаточно находиться на том же источнике (домен/протокол/порт), при этом URL-путь может быть разным.  
Объект localStorage доступен всем окнам из одного источника, поэтому, если мы устанавливаем данные в одном окне, изменения становятся видимыми в другом.

### Итого  

Объекты веб-хранилища localStorage и sessionStorage(Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.) позволяют хранить пары ключ/значение в браузере.

key и value должны быть строками.  
Лимит 2 Мб+, зависит от браузера.  
Данные не имеют «времени истечения».  
Данные привязаны к источнику (домен/протокол/порт).  
localStorage	sessionStorage  
Совместно используется между всеми вкладками и окнами с одинаковым источником	Разделяется в рамках вкладки браузера, среди ифреймов из того же источника  
«Переживает» перезапуск браузера	«Переживает» перезагрузку страницы (но не закрытие вкладки)  
API:  
setItem(key, value) – сохранить пару ключ/значение.  
getItem(key) – получить данные по ключу key.  
removeItem(key) – удалить значение по ключу key.  
clear() – удалить всё.  
key(index) – получить ключ на заданной позиции.  
length – количество элементов в хранилище.  
Используйте Object.keys для получения всех ключей.  
Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событиеstorage не срабатывает.  
Событие storage:  
Срабатывает при вызове setItem, removeItem, clear.  
Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.  
Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).  

## <a name="19"></a>3 IndexedDB

IndexedDB – это встроенная база данных, более мощная, чем localStorage.

Хранилище ключей/значений: доступны несколько типов ключей, а значения могут быть (почти) любыми.  
Поддерживает транзакции для надёжности.  
Поддерживает запросы в диапазоне ключей и индексы. 
Позволяет хранить больше данных, чем localStorage.

Для традиционных клиент-серверных приложений эта мощность обычно чрезмерна. IndexedDB предназначена для оффлайн приложений, можно совмещать с ServiceWorkers и другими технологиями.

Открыть базу данных  
Для начала работы с IndexedDB нужно открыть базу данных.

Синтаксис:  
```  
let openRequest = indexedDB.open(name, version);  
```  
name – название базы данных, строка.  
version – версия базы данных, положительное целое число, по умолчанию 1 (объясняется ниже).  
У нас может быть множество баз данных с различными именами, но все они существуют в контексте текущего источника (домен/протокол/порт). Разные сайты не могут получить доступ к базам данных друг друга.  
После этого вызова необходимо назначить обработчик событий для объекта openRequest:  
success: база данных готова к работе, готов «объект базы данных» openRequest.result, его следует использовать для дальнейших вызовов.  
error: не удалось открыть базу данных.  
upgradeneeded: база открыта, но её схема устарела (см. ниже).  
IndexedDB имеет встроенный механизм «версионирования схемы», который отсутствует в серверных базах данных.  
``` 
let openRequest = indexedDB.open("store", 1);
openRequest.onupgradeneeded = function() {
  // срабатывает, если на клиенте нет базы данных
  // ...выполнить инициализацию...
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // продолжить работу с базой данных, используя объект db
};
``` 

### Итого
IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.
Лучшим руководством является спецификация, текущая версия 2.0, но также поддерживаются несколько методов из 3.0 (не так много отличий) версии.  
Использование можно описать в нескольких фразах:  
Подключить обёртку над промисами, например idb.  
Открыть базу данных: idb.openDb(name, version, onupgradeneeded)  
Создание хранилищ объектов и индексов происходит в обработчике onupgradeneeded.  
Обновление версии – либо сравнивая номера версий, либо можно проверить что существует, а что нет.  
Для запросов:  
Создать транзакцию db.transaction('books') (можно указать readwrite, если надо).  
Получить хранилище объектов transaction.objectStore('books').  
Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.  
Для поиска по любому полю объекта создайте индекс.  
Если данные не помещаются в памяти, то используйте курсор.
